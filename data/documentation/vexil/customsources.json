{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagValueSource"},{"type":"text","text":" is effectively a plain key-value dictionary, the simplest source is exactly that: a "},{"type":"codeVoice","code":"Dictionary<String, Any>"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"There are the two methods from the protocol you need to implement: "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagValueSource\/flagValue(key:)"},{"type":"text","text":" and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagValueSource\/setFlagValue(_:key:)"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["class FlagValueDictionary: FlagValueSource {","","    var storage: [String: Any]","","    init (_ dictionary: [String: Any] = [:]) {","        self.storage = dictionary","    }","","    var name: String {","        return String(describing: Self.self)","    }","","    func flagValue<Value>(key: String) -> Value? where Value: FlagValue {","        return self.storage[key] as? Value","    }","","    func setFlagValue<Value>(_ value: Value?, key: String) throws where Value: FlagValue {","        if let value = value {","            self.storage.updateValue(value, forKey: key)","        } else {","            self.storage.removeValue(forKey: key)","        }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Thats it."}]},{"anchor":"Real-time-flag-value-publishing","level":2,"type":"heading","text":"Real-time flag value publishing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you’re using the "},{"type":"codeVoice","code":"Publisher"},{"type":"text","text":"s provided by Vexil though, you’ll want to make sure your custom source also notifies the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagPole"},{"type":"text","text":" when it is changed. To do that there is a simple additional function in the protocol you need to implement: "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagValueSource\/valuesDidChange(keys:)-7y64r"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"(At the time of writing this document, Combine is still not available on Linux, so we take care in our implementation. These conditional compilation steps are omitted from the examples for brevity.)"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here is a fuller example of the "},{"type":"codeVoice","code":"FlagValueDictionary"},{"type":"text","text":" above."}]},{"type":"codeListing","syntax":"swift","code":["class FlagValueDictionary: FlagValueSource {","","    var storage: [String: Any]","","    private var subject = PassthroughSubject<Set<String>, Never>()","","    init (_ dictionary: [String: Any] = [:]) {","        self.storage = dictionary","    }","","    var name: String {","        return String(describing: Self.self)","    }","","    func flagValue<Value> (key: String) -> Value? where Value: FlagValue {","        return self.storage[key] as? Value","    }","","    func setFlagValue<Value> (_ value: Value?, key: String) throws where Value: FlagValue {","        if let value = value {","            self.storage.updateValue(value, forKey: key)","        } else {","            self.storage.removeValue(forKey: key)","        }","        self.subject.send([key])","    }","    ","    func valuesDidChange (keys: Set<String>) -> AnyPublisher<Set<String>, Never>? {","        self.subject.eraseToAnyPublisher()","    }","}"]},{"anchor":"Boxing-flag-values","level":2,"type":"heading","text":"Boxing flag values"},{"type":"paragraph","inlineContent":[{"type":"text","text":"But not everything can be type-erased into an "},{"type":"codeVoice","code":"Any"},{"type":"text","text":" so easily. Sometimes you need to be able to “box” (encode or serialise) it into a different type. For example, "},{"type":"codeVoice","code":"UserDefaults"},{"type":"text","text":" stores all of its values as an "},{"type":"codeVoice","code":"NSObject"},{"type":"text","text":" subclass."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To make this simpler, Vexil provides the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/BoxedFlagValue"},{"type":"text","text":" type, and each "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagValue"},{"type":"text","text":" type needs to provide an implementation for boxing and unboxing its values into a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/BoxedFlagValue"},{"type":"text","text":". See "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/DefiningFlags"},{"type":"text","text":" for more on creating custom flag value types."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So when creating your custom source, you don’t need to be too concerned with trying to unpack the "},{"type":"codeVoice","code":"Value"},{"type":"text","text":" generic in your methods, you just need to work with the much simpler "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/BoxedFlagValue"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["public enum BoxedFlagValue: Equatable {","    case array([BoxedFlagValue])","    case bool(Bool)","    case dictionary([String: BoxedFlagValue])","    case data(Data)","    case double(Double)","    case float(Float)","    case integer(Int)","    case none","    case string(String)","}"]},{"anchor":"Unpacking-a-boxed-flag-value","level":3,"type":"heading","text":"Unpacking a boxed flag value"},{"type":"paragraph","inlineContent":[{"type":"text","text":"So in your custom source, you need only provide a translation between the source’s storage type and the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/BoxedFlagValue"},{"type":"text","text":". Here is the one for "},{"type":"codeVoice","code":"UserDefaults"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["extension BoxedFlagValue {","","    \/\/\/ Initialises a BoxedFlagValue from an \"Any\" object.","    \/\/\/","    \/\/\/ It does this by attempting to cast into the specified Swift type,","    \/\/\/ letting the bridging from the Objective-C types do the heavy lifting.","    \/\/\/","    \/\/\/ - Parameters:","    \/\/\/   - object:\t\t\tThe object returned by `UserDefaults.object(forKey:)`.","    \/\/\/   - typeHint:\t\tThe generic Value type, because we can cast any `Int` into a `Bool` and sometimes we need a hint","    \/\/\/","    init?<Value> (object: Any, typeHint: Value.Type) {","        switch object {","        ","        \/\/ we only try to cast to Bool if the caller is expecting a Bool","        case let value as Bool where typeHint == Bool.self:","            self = .bool(value)","","        case let value as Data:             self = .data(value)","        case let value as Int:              self = .integer(value)","        case let value as Float:            self = .float(value)","        case let value as Double:           self = .double(value)","        case let value as String:           self = .string(value)","        case is NSNull:                     self = .none","","        case let value as [Any]:            self = .array(value.compactMap({ BoxedFlagValue(object: $0, typeHint: typeHint) }))","        case let value as [String: Any]:    self = .dictionary(value.compactMapValues({ BoxedFlagValue(object: $0, typeHint: typeHint) }))","","        default:","            return nil","        }","    }","","    \/\/\/ Returns the NSObject subclass that `UserDefaults` is expecting for the receiving boxed flag value","    \/\/\/","    var object: NSObject {","        switch self {","        case let .array(value):         return value.map({ $0.object }) as NSArray","        case let .bool(value):          return value as NSNumber","        case let .data(value):          return value as NSData","        case let .dictionary(value):    return value.mapValues({ $0.object }) as NSDictionary","        case let .double(value):        return value as NSNumber","        case let .float(value):         return value as NSNumber","        case let .integer(value):       return value as NSNumber","        case .none:                     return NSNull()","        case let .string(value):        return value as NSString","        }","    }","}"]},{"anchor":"Implementing-doc:\/\/Vexil\/documentation\/Vexil\/FlagValueSource","level":3,"type":"heading","text":"Implementing ``doc:\/\/Vexil\/documentation\/Vexil\/FlagValueSource``"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Once we have that translation between a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/BoxedFlagValue"},{"type":"text","text":" and "},{"type":"codeVoice","code":"NSObject"},{"type":"text","text":" done, the rest of implementing "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagValueSource"},{"type":"text","text":" for "},{"type":"codeVoice","code":"UserDefaults"},{"type":"text","text":" becomes pretty simple:"}]},{"type":"codeListing","syntax":"swift","code":["extension UserDefaults: FlagValueSource {","","    public var name: String {","        return \"UserDefaults\\(self == UserDefaults.standard ? \".standard\" : \"\")\"","    }","","    public func flagValue<Value>(key: String) -> Value? where Value: FlagValue {","","        \/\/ get the NSObject for the specified key and translate it into a `BoxedFlagValue`","        guard","            let object = self.object(forKey: key),","            let boxed = BoxedFlagValue(object: object, typeHint: Value.self)","        else { return nil }","","        return Value(boxedFlagValue: boxed)","    }","","    public func setFlagValue<Value>(_ value: Value?, key: String) throws where Value: FlagValue {","        guard let value = value else {","            self.removeObject(forKey: key)","            return","        }","","        \/\/ get the `NSObject` from the `BoxedFlagValue` and set it in the user defaults","        self.set(value.boxedFlagValue.object, forKey: key)","","    }","","    public func valuesDidChange (keys: Set<String>) -> AnyPublisher<Set<String>, Never>? {","        return NotificationCenter.default.publisher(for: UserDefaults.didChangeNotification)","            .map { _ in [] }","            .eraseToAnyPublisher()","    }","}"]},{"anchor":"Working-with-generic-sources","level":2,"type":"heading","text":"Working with generic sources"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/BoxedFlagValue"},{"type":"text","text":" alone is all you need if you’re wrapping a key-value store that uses a concrete type, or something you can cast in the right types. But that doesn’t help us at all if your provider also supports generics as we have no way for the compiler to infer that "},{"type":"codeVoice","code":"Value"},{"type":"text","text":", which must conform to "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagValue"},{"type":"text","text":", also conforms to "},{"type":"codeVoice","code":"MyFlagProviderValue"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To work around this limitation, Vexil’s "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagValue"},{"type":"text","text":" provides an associated type that describes the type stored inside the boxed value: "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagValue\/BoxedValueType"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s say we working with Awesome Flag Provider™, and they provided an interface that looked like this:"}]},{"type":"codeListing","syntax":"swift","code":["protocol AwesomeFlagType {}","extension Bool: AwesomeFlagType {}\t\t\/\/ plus other types","","class AwesomeFlagProvider {","","    func get<Value> (key: String) -> Value? where Value: AwesomeFlagType {","        \/\/ some awesome logic","        return nil","    }","","    func set<Value> (_ value: Value, key: String) where Value: AwesomeFlagType {","        \/\/ more awesome logic","    }","","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If we were to attempt to use "},{"type":"codeVoice","code":"get(key:)"},{"type":"text","text":" directly we’d get an error:"}]},{"type":"codeListing","syntax":"swift","code":["extension AwesomeFlagProvider: FlagValueSource {","    var name: String { \"My Awesome Flag Provider\" }","","    func flagValue<Value>(key: String) -> Value? where Value: FlagValue {","        return self.get(key: key)\t\t\/\/ ERROR! Instance method 'get(key:)' requires that 'Value' conform to 'AwesomeFlagType'","    }","","    func setFlagValue<Value>(_ value: Value?, key: String) throws where Value: FlagValue {","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And there is no real way with the current generics implementations for us to make them conform:"}]},{"type":"codeListing","syntax":null,"code":["\/\/ ERROR! Type 'AwesomeFlagProvider' does not conform to protocol 'FlagValueSource'","func flagValue<Value>(key: String) -> Value? where Value: FlagValue & AwesomeFlagType {","    return self.get(key: key)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"But since a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagValue"},{"type":"text","text":" can be anything, you use the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagValue"},{"type":"text","text":"’s "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagValue\/BoxedValueType"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["func flagValue<Value>(key: String) -> Value? where Value: FlagValue {","    if Value.BoxedValueType.self == Bool.self || Value.BoxedValueType.self == Bool?.self {","        let value: Bool? = self.get(key: key)","        return value as? Value","    }","","    \/\/ support for other types","","    return nil","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To be honest, this feels quite horrible but seems to be the only way to make the compiler happy. "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagValue\/BoxedValueType"},{"type":"text","text":" is provided solely so the possible types you need to check for is more limited than "},{"type":"emphasis","inlineContent":[{"type":"text","text":"everything"}]},{"type":"text","text":"."}]}]}],"schemaVersion":{"major":0,"minor":1,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/vexil\/customsources"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Vexil\/documentation\/Vexil\/CustomSources","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"A basic walkthrough in creating a custom "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagValueSource"},{"type":"text","text":", using the bundled sources as examples."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Creating Custom Flag Value Sources","role":"article","modules":[{"name":"Vexil"}]},"hierarchy":{"paths":[["doc:\/\/Vexil\/documentation\/Vexil"]]},"seeAlsoSections":[{"title":"Sources","identifiers":["doc:\/\/Vexil\/documentation\/Vexil\/FlagValueSource","doc:\/\/Vexil\/documentation\/Vexil\/FlagValueDictionary","doc:\/\/Vexil\/documentation\/Vexil\/BoxedFlagValue"],"generated":true}],"references":{"doc://Vexil/documentation/Vexil/FlagValue":{"role":"symbol","title":"FlagValue","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"FlagValue"}],"abstract":[{"type":"text","text":"A type that represents the wrapped value of a "},{"type":"codeVoice","code":"Flag"}],"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagValue","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"FlagValue"}],"url":"\/documentation\/vexil\/flagvalue"},"doc://Vexil/documentation/Vexil/FlagValueSource":{"role":"symbol","title":"FlagValueSource","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"FlagValueSource"}],"abstract":[{"type":"text","text":"A simple protocol that describes a source of "},{"type":"codeVoice","code":"FlagValue"},{"type":"text","text":"s"}],"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagValueSource","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"FlagValueSource"}],"url":"\/documentation\/vexil\/flagvaluesource"},"doc://Vexil/documentation/Vexil/FlagContainer":{"role":"symbol","title":"FlagContainer","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"FlagContainer"}],"abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"FlagContainer"},{"type":"text","text":" is a type that encapsulates your "},{"type":"codeVoice","code":"Flag"},{"type":"text","text":" and "},{"type":"codeVoice","code":"FlagGroup"},{"type":"text","text":" "},{"type":"text","text":"types. The only requirement of a "},{"type":"codeVoice","code":"FlagContainer"},{"type":"text","text":" is that it can be initialised"},{"type":"text","text":" "},{"type":"text","text":"with an empty "},{"type":"codeVoice","code":"init()"},{"type":"text","text":"."}],"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagContainer","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"FlagContainer"}],"url":"\/documentation\/vexil\/flagcontainer"},"doc://Vexil/documentation/Vexil/DefiningFlags":{"role":"article","title":"Defining Flags","abstract":[{"type":"text","text":"Defining Flags is the cornerstone of Vexil. Learn how to structure your "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagContainer"},{"type":"text","text":", use "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagGroup"},{"type":"text","text":"s and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/Flag"},{"type":"text","text":"s of various types."}],"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/DefiningFlags","kind":"article","type":"topic","url":"\/documentation\/vexil\/definingflags"},"doc://Vexil/documentation/Vexil/Flag":{"role":"symbol","title":"Flag","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Flag"}],"abstract":[{"type":"text","text":"A wrapper representing a Feature Flag \/ Feature Toggle."}],"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/Flag","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Flag"}],"url":"\/documentation\/vexil\/flag"},"doc://Vexil/documentation/Vexil/FlagValueSource/flagValue(key:)":{"role":"symbol","title":"flagValue(key:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"flagValue"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"Value"},{"kind":"text","text":">("},{"kind":"externalParam","text":"key"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"String","preciseIdentifier":"s:SS"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"Value"},{"kind":"text","text":"?"}],"abstract":[{"type":"text","text":"Provide a way to fetch values"}],"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagValueSource\/flagValue(key:)","kind":"symbol","required":true,"type":"topic","url":"\/documentation\/vexil\/flagvaluesource\/flagvalue(key:)"},"doc://Vexil/documentation/Vexil":{"role":"collection","title":"Vexil","abstract":[{"type":"text","text":"Vexil (named for Vexillology) is a Swift package for managing feature flags (also called feature toggles) in a flexible, multi-provider way."}],"identifier":"doc:\/\/Vexil\/documentation\/Vexil","kind":"symbol","type":"topic","url":"\/documentation\/vexil"},"doc://Vexil/documentation/Vexil/FlagGroup":{"role":"symbol","title":"FlagGroup","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"FlagGroup"}],"abstract":[{"type":"text","text":"A wrapper representing a group of Feature Flags \/ Feature Toggles."}],"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagGroup","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"FlagGroup"}],"url":"\/documentation\/vexil\/flaggroup"},"doc://Vexil/documentation/Vexil/BoxedFlagValue":{"role":"symbol","title":"BoxedFlagValue","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"BoxedFlagValue"}],"abstract":[{"type":"text","text":"An intermediate type used to make encoding and decoding of types simpler for "},{"type":"codeVoice","code":"FlagValueSource"},{"type":"text","text":"s"}],"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/BoxedFlagValue","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"BoxedFlagValue"}],"url":"\/documentation\/vexil\/boxedflagvalue"},"doc://Vexil/documentation/Vexil/FlagValueSource/valuesDidChange(keys:)-7y64r":{"role":"symbol","title":"valuesDidChange(keys:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"valuesDidChange"},{"kind":"text","text":"("},{"kind":"externalParam","text":"keys"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Set","preciseIdentifier":"s:Sh"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"String","preciseIdentifier":"s:SS"},{"kind":"text","text":">) -> "},{"kind":"typeIdentifier","text":"AnyPublisher","preciseIdentifier":"s:7Combine12AnyPublisherV"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Set","preciseIdentifier":"s:Sh"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"String","preciseIdentifier":"s:SS"},{"kind":"text","text":">, "},{"kind":"typeIdentifier","text":"Never","preciseIdentifier":"s:s5NeverO"},{"kind":"text","text":">?"}],"abstract":[{"type":"text","text":"If you’re running on a platform that supports Combine you can optionally support real-time"},{"type":"text","text":" "},{"type":"text","text":"flag updates."}],"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagValueSource\/valuesDidChange(keys:)-7y64r","kind":"symbol","type":"topic","url":"\/documentation\/vexil\/flagvaluesource\/valuesdidchange(keys:)-7y64r"},"doc://Vexil/documentation/Vexil/FlagValue/BoxedValueType":{"role":"symbol","title":"BoxedValueType","fragments":[{"kind":"keyword","text":"associatedtype"},{"kind":"text","text":" "},{"kind":"identifier","text":"BoxedValueType"},{"kind":"text","text":" = "},{"kind":"typeIdentifier","text":"Data","preciseIdentifier":"s:10Foundation4DataV"}],"abstract":[{"type":"text","text":"The type that this "},{"type":"codeVoice","code":"FlagValue"},{"type":"text","text":" would be boxed into."},{"type":"text","text":" "},{"type":"text","text":"Used by "},{"type":"codeVoice","code":"FlagValueSource"},{"type":"text","text":"s to provide interop with different providers"}],"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagValue\/BoxedValueType","kind":"symbol","required":true,"type":"topic","url":"\/documentation\/vexil\/flagvalue\/boxedvaluetype"},"doc://Vexil/documentation/Vexil/FlagValueDictionary":{"role":"symbol","title":"FlagValueDictionary","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"FlagValueDictionary"}],"abstract":[{"type":"text","text":"A simple dictionary-backed FlagValueSource that can be useful for testing"},{"type":"text","text":" "},{"type":"text","text":"and other purposes."}],"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagValueDictionary","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"FlagValueDictionary"}],"url":"\/documentation\/vexil\/flagvaluedictionary"},"doc://Vexil/documentation/Vexil/FlagPole":{"role":"symbol","title":"FlagPole","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"FlagPole"}],"abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"FlagPole"},{"type":"text","text":" hoists a group of feature flags \/ feature toggles."}],"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagPole","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"FlagPole"}],"url":"\/documentation\/vexil\/flagpole"},"doc://Vexil/documentation/Vexil/FlagValueSource/setFlagValue(_:key:)":{"role":"symbol","title":"setFlagValue(_:key:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"setFlagValue"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"Value"},{"kind":"text","text":">("},{"kind":"typeIdentifier","text":"Value"},{"kind":"text","text":"?, "},{"kind":"externalParam","text":"key"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"String","preciseIdentifier":"s:SS"},{"kind":"text","text":") "},{"kind":"keyword","text":"throws"}],"abstract":[{"type":"text","text":"And to save values – if your source does not support saving just do nothing"}],"identifier":"doc:\/\/Vexil\/documentation\/Vexil\/FlagValueSource\/setFlagValue(_:key:)","kind":"symbol","required":true,"type":"topic","url":"\/documentation\/vexil\/flagvaluesource\/setflagvalue(_:key:)"}}}